// node_modules/@web-applets/sdk/dist/utils.js
function parseUrl(url, base) {
  if (!url)
    return "";
  try {
    if (base) {
      if (!base.match(/\.[a-zA-Z0-9]+$/)) {
        base = base.endsWith("/") ? base : base + "/";
      }
    }
    const resolvedUrl = new URL(url, base ?? window.location.href);
    return trimTrailingSlash(resolvedUrl.href);
  } catch (e) {
    console.warn("Failed to parse URL:", e);
    return url;
  }
}
function trimTrailingSlash(url) {
  if (url.endsWith("/")) {
    return url.slice(0, -1);
  }
  return url;
}

// node_modules/@web-applets/sdk/dist/core/shared.js
async function loadManifest(pageUrl) {
  pageUrl = parseUrl(pageUrl);
  let manifest;
  try {
    const pageRequest = await fetch(pageUrl);
    const html = await pageRequest.text();
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, "text/html");
    const linkElem = doc.querySelector('link[rel="manifest"]');
    const href = linkElem.getAttribute("href");
    const manifestUrl = parseUrl(href, pageUrl);
    const manifestRequest = await fetch(manifestUrl);
    manifest = await manifestRequest.json();
    manifest.icons = manifest.icons.map((icon) => {
      icon.src = parseUrl(icon.src, pageUrl);
      return icon;
    });
  } catch (e) {
    return;
  }
  return manifest;
}
var AppletMessageRelay = class {
  constructor(target) {
    this.target = target;
  }
  async send(message, options) {
    this.target.postMessage(message.toJson(), "*");
    if (options && options.resolves === false)
      return;
    return new Promise((resolve) => {
      const listener = (messageEvent) => {
        const responseMessage = new AppletMessage(messageEvent.data.type, messageEvent.data);
        if (responseMessage.type === "resolve" && responseMessage.id === message.id) {
          window.removeEventListener("message", listener);
          resolve(responseMessage);
        }
      };
      window.addEventListener("message", listener);
    });
  }
  async on(messageType, callback) {
    const listener = async (messageEvent) => {
      if (messageEvent.source === window.self)
        return;
      if (messageEvent.data.type !== messageType)
        return;
      const message = new AppletMessage(messageEvent.data.type, messageEvent.data);
      await callback(message);
      const resolveMessage = new AppletResolveMessage({ id: message.id });
      this.send(resolveMessage, { resolves: false });
    };
    window.addEventListener("message", listener);
  }
};
var AppletMessage = class {
  constructor(type, values) {
    this.timeStamp = Date.now();
    this.type = type;
    this.id = crypto.randomUUID();
    if (values)
      Object.assign(this, values);
  }
  toJson() {
    return Object.fromEntries(Object.entries(this).filter(([_, value]) => {
      try {
        JSON.stringify(value);
        return true;
      } catch {
        return false;
      }
    }));
  }
};
var AppletResolveMessage = class extends AppletMessage {
  constructor({ id }) {
    super("resolve");
    this.id = id;
  }
};
var AppletActionsMessage = class extends AppletMessage {
  constructor({ actions }) {
    super("actions");
    this.actions = actions;
  }
};
var AppletDataMessage = class extends AppletMessage {
  constructor({ data }) {
    super("data");
    this.data = data;
  }
};
var AppletReadyMessage = class extends AppletMessage {
  constructor() {
    super("ready");
  }
};
var AppletResizeMessage = class extends AppletMessage {
  constructor({ dimensions }) {
    super("resize");
    this.dimensions = dimensions;
  }
};
var AppletActionMessage = class extends AppletMessage {
  constructor({ actionId, params }) {
    super("action");
    this.actionId = actionId;
    this.params = params;
  }
};
var AppletInitMessage = class extends AppletMessage {
  constructor() {
    super("init");
  }
};
var AppletDataEvent = class extends Event {
  constructor({ data }) {
    super("data", {
      bubbles: false,
      cancelable: false,
      composed: false
    });
    this.data = data;
  }
};
var AppletReadyEvent = class extends Event {
  constructor() {
    super("ready", {
      bubbles: false,
      cancelable: false,
      composed: false
    });
  }
};
var AppletLoadEvent = class extends Event {
  constructor() {
    super("load", {
      bubbles: false,
      cancelable: false,
      composed: false
    });
  }
};
var AppletActionsEvent = class extends Event {
  constructor({ actions }) {
    super("actions", {
      bubbles: false,
      cancelable: false,
      composed: false
    });
    this.actions = actions;
  }
};
var AppletResizeEvent = class extends Event {
  constructor({ dimensions }) {
    super("resize", {
      bubbles: false,
      cancelable: false,
      composed: false
    });
    this.dimensions = dimensions;
  }
};

// node_modules/@web-applets/sdk/dist/core/applet.js
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Applet_instances;
var _Applet_manifest;
var _Applet_data;
var _Applet_addListeners;
var hiddenContainer = document.createElement("iframe");
hiddenContainer.style.display = "none";
document.body.appendChild(hiddenContainer);
async function load(url, container) {
  if (!container)
    container = hiddenContainer;
  url = parseUrl(url);
  const manifest = await loadManifest(url);
  container.setAttribute("sandbox", "allow-scripts allow-forms");
  container.src = url;
  const applet = new Applet(manifest, container.contentWindow);
  return new Promise((resolve) => {
    applet.onready = () => resolve(applet);
  });
}
var Applet = class extends EventTarget {
  constructor(manifest, targetWindow) {
    super();
    _Applet_instances.add(this);
    this.actions = [];
    _Applet_manifest.set(this, void 0);
    _Applet_data.set(this, void 0);
    this.messageRelay = new AppletMessageRelay(targetWindow);
    __classPrivateFieldSet(this, _Applet_manifest, manifest, "f");
    __classPrivateFieldGet(this, _Applet_instances, "m", _Applet_addListeners).call(this);
    this.messageRelay.on("ready", () => {
      this.messageRelay.send(new AppletInitMessage());
    });
  }
  async dispatchAction(actionId, params) {
    const actionMessage = new AppletActionMessage({
      actionId,
      params
    });
    return await this.messageRelay.send(actionMessage);
  }
  get data() {
    return __classPrivateFieldGet(this, _Applet_data, "f");
  }
  set data(data) {
    __classPrivateFieldSet(this, _Applet_data, data, "f");
    this.messageRelay.send(new AppletDataMessage({ data }));
  }
  get manifest() {
    return __classPrivateFieldGet(this, _Applet_manifest, "f");
  }
  onready(event) {
  }
  onresize(event) {
  }
  onactions(event) {
  }
  ondata(event) {
  }
};
_Applet_manifest = /* @__PURE__ */ new WeakMap(), _Applet_data = /* @__PURE__ */ new WeakMap(), _Applet_instances = /* @__PURE__ */ new WeakSet(), _Applet_addListeners = function _Applet_addListeners2() {
  this.messageRelay.on("ready", (message) => {
    const readyEvent = new AppletReadyEvent();
    if (typeof this.onready === "function")
      this.onready(readyEvent);
    this.dispatchEvent(readyEvent);
  });
  this.messageRelay.on("data", (message) => {
    __classPrivateFieldSet(this, _Applet_data, message.data, "f");
    const dataEvent = new AppletDataEvent({ data: message.data });
    if (typeof this.ondata === "function")
      this.ondata(dataEvent);
    this.dispatchEvent(dataEvent);
  });
  this.messageRelay.on("resize", (message) => {
    const resizeEvent = new AppletResizeEvent({
      dimensions: message.dimensions
    });
    if (typeof this.onresize === "function")
      this.onresize(resizeEvent);
    this.dispatchEvent(resizeEvent);
  });
  this.messageRelay.on("actions", (message) => {
    this.actions = message.actions;
    const actionsEvent = new AppletActionsEvent({ actions: message.actions });
    if (typeof this.onactions === "function")
      this.onactions(actionsEvent);
    this.dispatchEvent(actionsEvent);
  });
};

// node_modules/@web-applets/sdk/dist/core/context.js
var __classPrivateFieldGet2 = function(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _AppletContext_actions;
var _AppletContext_data;
var AppletContext = class extends EventTarget {
  constructor() {
    super();
    this.actionHandlers = {};
    _AppletContext_actions.set(this, {});
    _AppletContext_data.set(this, void 0);
    this.connect();
  }
  connect() {
    this.messageRelay = new AppletMessageRelay(window.parent);
    if (document.readyState === "complete" || document.readyState === "interactive") {
      setTimeout(this.initialize.bind(this), 1);
    } else {
      window.addEventListener("DOMContentLoaded", this.initialize.bind(this));
    }
    this.createResizeObserver();
    this.attachListeners();
  }
  async initialize() {
    const manifestLinkElem = document.querySelector('link[rel="manifest"]');
    if (!manifestLinkElem)
      return;
    try {
      const manifestRequest = await fetch(manifestLinkElem.href);
      const manifest = await manifestRequest.json();
      this.manifest = manifest;
      this.actions = manifest.actions ?? [];
    } catch (e) {
      return;
    }
    const loadEvent = new AppletLoadEvent();
    this.dispatchEvent(loadEvent);
    if (typeof this.onload === "function")
      await this.onload(loadEvent);
    this.messageRelay.send(new AppletReadyMessage());
    const readyEvent = new AppletReadyEvent();
    this.dispatchEvent(readyEvent);
    if (typeof this.onready === "function")
      this.onready(readyEvent);
  }
  createResizeObserver() {
    const resizeObserver = new ResizeObserver((entries) => {
      for (let entry of entries) {
        const message = new AppletMessage("resize", {
          dimensions: {
            width: entry.contentRect.width,
            height: entry.contentRect.height
          }
        });
        this.messageRelay.send(message);
      }
    });
    resizeObserver.observe(document.querySelector("html"));
  }
  attachListeners() {
    this.messageRelay.on("init", (message) => {
      var _a;
      this.manifest = message.manifest;
      this.actions = ((_a = this.manifest) == null ? void 0 : _a.actions) || [];
    });
    this.messageRelay.on("data", (message) => {
      this.setData(message.data);
    });
    this.messageRelay.on("action", async (message) => {
      if (Object.keys(this.actionHandlers).includes(message.actionId)) {
        await this.actionHandlers[message.actionId](message.params);
      }
    });
  }
  setActionHandler(actionId, handler) {
    this.actionHandlers[actionId] = handler;
  }
  defineAction(actionId, definition) {
    const { handler, ...properties } = definition;
    this.actions = [
      ...this.actions,
      {
        id: actionId,
        ...properties
      }
    ];
    this.setActionHandler(actionId, handler);
  }
  set actions(actions) {
    if (!actions)
      return;
    for (let action of actions) {
      __classPrivateFieldGet2(this, _AppletContext_actions, "f")[action.id] = action;
    }
    this.messageRelay.send(new AppletActionsMessage({ actions: this.actions }));
  }
  get actions() {
    return Object.values(__classPrivateFieldGet2(this, _AppletContext_actions, "f"));
  }
  set data(data) {
    this.setData(data);
  }
  get data() {
    return __classPrivateFieldGet2(this, _AppletContext_data, "f");
  }
  async setData(data) {
    const dataMessage = new AppletMessage("data", { data });
    await this.messageRelay.send(dataMessage);
    __classPrivateFieldSet2(this, _AppletContext_data, data, "f");
    const dataEvent = new AppletDataEvent({ data });
    this.dispatchEvent(dataEvent);
    this.ondata(dataEvent);
  }
  onload(event) {
  }
  onready(event) {
  }
  ondata(event) {
  }
};
_AppletContext_actions = /* @__PURE__ */ new WeakMap(), _AppletContext_data = /* @__PURE__ */ new WeakMap();
function getContext() {
  return new AppletContext();
}

// node_modules/@web-applets/sdk/dist/index.js
var applets = {
  load,
  getContext
};
export {
  Applet,
  AppletActionMessage,
  AppletActionsEvent,
  AppletActionsMessage,
  AppletContext,
  AppletDataEvent,
  AppletDataMessage,
  AppletInitMessage,
  AppletLoadEvent,
  AppletMessage,
  AppletMessageRelay,
  AppletReadyEvent,
  AppletReadyMessage,
  AppletResizeEvent,
  AppletResizeMessage,
  AppletResolveMessage,
  applets,
  getContext,
  load,
  loadManifest
};
//# sourceMappingURL=@web-applets_sdk.js.map
